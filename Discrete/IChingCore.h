/*	File:		IChingCore.h	Contains:	Header file to access IChingCore.c functions	Written by:	Peter Castine	Copyright:	© 2001-2002 Peter Castine	Change History (most recent first):         <2>  28Ð11Ð2002    pc      Tidy up after initial check in.         <1>  28Ð11Ð2002    pc      Initial check in.		10-Jul-2001:	First implementation*//****************************************************************************************** ******************************************************************************************/#pragma once#pragma mark ¥ Include Files#include "LitterLib.h"			// For access to the Taus88 generator#pragma mark ¥ Constants	// Symbolic constants we use a lotenum IChingMethods {	yyCoin		= 0,	yyYarrow,		yyDefault	= yyCoin	};enum YinYang {	yin			= 2,				// The code relies on the traditional values	yang							// assigned to yin and yang.	};enum LineValue {	oldYin		= 6,				// Constants for yarrow sticks (cf. Richard Wilhelm)	youngYang,						// Note that the convention for coins is reversed	youngYin,						// vis young yin and yang.	oldYang	};	// Sizes of arrays#define	kYarrowStickCount	50#define	kLineComponents		 3#define	kLineCount			 6#define	kDetailLen			18		// kLineComponents * kLineCount#define	kMaxOracleLen		 8		// If all lines change, then the main oracle, followed									// by six individaul lines, plus the final oracle	// Hexagram bitmap representationenum LineBit {	lineBottom			= 0x01,	lineSecond			= 0x02,	lineThird			= 0x04,	lineFourth			= 0x08,	lineFifth			= 0x10,	lineTop				= 0x20,		lineMaskLowTri		= 0x07,	lineMaskTopTri		= 0x38,	lineMaskLowMidTri	= 0x0e,	lineMaskTopMidTri	= 0x1c,	lineMaskAll			= 0x3f,				// sum of lineBottom .. lineTop		linesNone			= 0x00				// Special constant for rulers	};	// Trigramsenum Trigram {	triChien		= 1,	triKun,	triChen,	triKan,	triKen,	triSun,	triLi,	triTui	};#pragma mark ¥ Type Definitionstypedef enum IChingMethods	eChingMethods;typedef enum YinYang		eYinYang;typedef enum LineValue		eLineValue;typedef struct Line {			eLineValue	value;			eYinYang	components[kLineComponents];			} tLine;typedef tLine*	tLinePtr;	typedef enum Trigram	eTrigram;typedef enum LineBit	eLineBits;		// Can be sum of any number of lineBit elementstypedef	unsigned		tHexagram;		// Consistency would have this done as an enum,typedef Byte			tPackHexagram;	// but the day is only so long. In Pascal it										// would have been possible to limit the range										// to [1 .. 64].										typedef struct Oracle {			int		mainHexagram,					futureHexagram;			tLine	lines[kLineCount];			} tOracle;typedef tOracle* tOraclePtr;typedef void(*ChingFunc)(tOraclePtr);typedef struct HexagramInfo {	eLineBits	theLines,				// Bits set for Yin lines;										// yang lines are clear.														gov,					// Governing rulers				con;					// Constitutional rulers		eTrigram	house;	Byte		housePos;				// Index in [1 .. 8]	} tHexInfo;typedef tHexInfo* tHexInfoPtr;#pragma mark ¥ Global Variables & Lookup Arraysextern const tPackHexagram	kIChingMap[64];extern const eTrigram		kTrigramMap[8];extern const eTrigram		kRevTrigramBits[8];extern const tHexInfo		kHexagramInfo[64];#pragma mark ¥ Function Prototypesvoid	ThrowSticks(tOraclePtr);void	TossCoins(tOraclePtr);static inline eTrigram		BottomTrigram	(eLineBits);static inline eTrigram		TopTrigram		(eLineBits);static inline eTrigram		LowMidTrigram	(eLineBits);static inline eTrigram		UpMidTrigram	(eLineBits);static inline tHexagram	Inverse			(eLineBits);static inline tHexagram	Reverse			(eLineBits);static inline tHexagram	Exchange		(eLineBits);#pragma mark ¥ Inlined Functionsstatic inline eTrigram	BottomTrigram	(eLineBits iHex)			{ return kTrigramMap[iHex & lineMaskLowTri]; }static inline eTrigram	TopTrigram		(eLineBits iHex)			{ return kTrigramMap[(iHex & lineMaskTopTri) >> 3]; }static inline eTrigram	LowMidTrigram	(eLineBits iHex)			{ return kTrigramMap[(iHex & lineMaskLowMidTri) >> 1]; }static inline eTrigram	UpMidTrigram	(eLineBits iHex)			{ return kTrigramMap[(iHex & lineMaskTopMidTri) >> 2]; }static inline tHexagram	Inverse(eLineBits iHex)			{ return kIChingMap[~iHex & lineMaskAll]; }			static inline tHexagram	Reverse(eLineBits iHex)			{			unsigned rIndex = 						(kRevTrigramBits[iHex & lineMaskLowTri] << 3)						+ kRevTrigramBits[(iHex & lineMaskTopTri) >> 3];						return kIChingMap[rIndex];			}			static inline tHexagram	Exchange(eLineBits iHex)			{			unsigned xIndex = ((iHex & lineMaskLowTri) << 3)								+ ((iHex & lineMaskTopTri) >> 3);							return kIChingMap[xIndex];			}